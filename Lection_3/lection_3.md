# Особенности языка
## Как обрабатывать исключения в Python?
finally - в единственном числе. Он выполняется всегда.
ексепт отсуствует если есть финали, а финали отсувтует если есть ексепт.
Одновременно они не могут отсутсовать.
```python
# Как обрабатывать исключения в Python?
# Проще попросить прощения, чем разрешения
try:
# код, в котором потенциально может появиться исключение
    a = int(input('Делимое: '))
    b = int(input('Делитель: '))
    print(f'Частное: {a / b}')
except ZeroDivisionError:
# обработка исключения
    print('Делитель не может быть нулем')
except ValueError:
    print('Делимое и делитель должны быть числом')
else:
    print('Молодец, ты справился с вводом данных')
finally:
    print('Спасибо, что воспользовались нашим калькулятором')1234567891011121314
```
Несколько исключений
```python
try:
    a = int(input('Делимое: '))
    b = int(input('Делитель: '))
    print(f'Частное: {a / b}')
except (ZeroDivisionError, ValueError) as err:
    print(err)

```
# Контекстный менеджер
**Менеджер контекста** управляет входом в нужный контекст выполнения и выходом из него для выполнения
блока кода:
```python
with <выражение> [as <переменная>][, <выражение> [as <переменная>]]:
<блок_кода>
```
```python
try:
    f = open('/proc/cpuinfo')
    info = list(filter(lambda i: i.strip(), f))
finally:
    f.close()
```

Закрывает файл контексный менеджер
```python
with open('/proc/cpuinfo') as f:
    info = list(filter(lambda i: i.strip(), f))
```
Для контекста два метода :
1) __enter__() - вход в контекст и возвращение объекта
2)  __exit__() - выход из контекста
 ## Итераторы
За место фора типо

**Итератор** - это объект, который позволяет поочередно получать элементы коллекции.

Итератор в Python - это объект, который реализует **протокол итерации**: 
- __iter__() - возвращает объект-итератор
- __next__() - возвращает следующий элемент, или выбрасывает исключение StopIteration

Python предоставляет итераторы для: str, tuple, list, set, dict и д.р.

Python автоматически вызывает методы __iter__() и __next__() в цикле for

Что и как можно итерировать?
```python
product_name = 'Говорящий хомячок'
for c in product_name:
# Строки итерируются посимвольно
    print(c)
```
```python
hamster_names = ['Хома', 'Сеня', 'Роза', 'Соня']# hamster_names = ('Хома', 'Сеня', 'Роза', 'Соня')
# hamster_names = {'Хома', 'Сеня', 'Роза', 'Соня'}
for name in hamster_names:
# Списки, кортежи, множества
# итерируются по элементам
    print(name)
```
```python
for i, name in enumerate(hamster_names):
# Элементы можно пронумеровать
    print(f'Index: {i}, Value: {name}')
```
```python
product = {'name': 'Колесико', 'price': 1499.99, 'count': 10}
for i in product:
    # Словари итерируются по ключам
    print(i)# => 'name' 'price' 'count'
```

```python
for value in product.values():
    # Можно итерировать по значениям
    print(value)
```

```python
for key, value in product.items():
# Можно итерировать по ключам и значениям
print(f'{key}: {value}')
```

## Генераторы
**Генератор** - это функция, которая воспроизводит последовательность значений

Инструкция ``yield`` возвращает результат, и выполнение функции приостанавливается в этой точке:
```python
def generator():
    print('Шаг №1')
    yield 1
    print('Шаг №2')
    yield 2
    print('Шаг №3')
gen = generator() # Объект генератора создан123456789print(next(gen))
print(next(gen)) # Печатает 'Шаг №1' и возвращает 110print(next(gen))
print(next(gen)) # Печатает 'Шаг №2' и возвращает 211print(next(gen))
print(next(gen)) # Печатает 'Шаг №3' и выбрасывает исключение StopIteration12
```
Выполнение функции возобновляется с инструкции, следующей за ``yield``, когда метод ``__next__()`` будет вызван
снова 

Нет смысла использовать return - выйти из генератора return None
```text
| Характеристика      | Итератор                         | Генератор               |
|---------------------|-------------------------         |-------------------------|
| Создание            | Класс с методами                 | Функция с `yield`      |
| Состояние           | В атрибутах класса               | В локальных переменных   |
| Память              | Может использовать больше памяти | Использует меньше памяти |
```

```python 
from urllib.request import urlopen
def iter_pages(urls):
    """Генератор возвращает содержимое веб документов."""
    for url in urls:
        yield urlopen(url).read()
        
urls = ('https://python.org/', 'https://docs.python.org/3/')

for content in iter_pages(urls):
    print(content)
```
Для генераторов считается недопустимым по завершении итераций возвращать значение, отличное от None
