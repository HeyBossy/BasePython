```threading, concurrent.futures, multiprocessing, asyncio```

**Модели вычислений**

Это способы организации вычислительных процессов:

• как выполняются вычисления

• какие ресурсы используются

• как они взаимодействуют друг с другом

• какие ограничения на них накладываются

**Последовательная модель**

Вычисления выполняются пошагово, каждый шаг завершает одну операцию, прежде чем приступить к
следующей

Эта модель не предполагает приостановку одной задачи, чтобы выполнить другую

# Конкурентность | Параллелизм
**Конкурентность** - две или более задач выполняются в одно и то же время - мы можем переключаться между
ними, дав немного поработать сначала одной, а потом другой задаче

**Параллелизм** - две или более задач не просто чередуются, а выполняются строго одновременно - активны в
одно и то же время

Конкурентность можно организовать имея процессор всего с одним ядром, а параллелизм возможен только
на многоядерном процессоре
![img.png](img.png)
# Многопоточность
**Процесс** - работающее приложение, которому выделена область памяти, недоступная другим приложениям

**Поток (Thread)** - это минимальная единица работы, запланированная для выполнения операционной системой:

• создаются в рамках одного процесса

• разделяют с ним ресурсы (память, файловые дескрипторы и д.р.)

С одним процессом всегда ассоциирован один поток - **главный**

Процесс может создавать дополнительные потоки, которые
могут конкурентно выполнять задачи - это называется
**многопоточностью**

**Многопоточность** — это способ организации работы программ, при котором они могут выполнять несколько операций одновременно, используя отдельные "потоки" внутри одного процесса. Каждый поток может выполнять свою задачу независимо от других потоков.

Пример из жизни

Представьте, что вы находитесь в кафе, где один бариста готовит кофе. Если много клиентов пришло одновременно, им придётся ждать своей очереди. Теперь представьте, что в кафе работают несколько бариста. Каждый из них может готовить кофе для разных клиентов одновременно. Это значительно ускоряет обслуживание и делает его более эффективным. В этом примере бариста — это потоки, а заказы на кофе — задачи, которые программа должна выполнить.

Пример и результат - **ThreadPoolExecutor**
```python
 concurrent.futures import ThreadPoolExecutor
import itertools
def multi_thread_concurrent(n: int, max_workers: int | None = None) -> list[int]:
    data_range = range(1, n + 1)
    
    with ThreadPoolExecutor(max_workers) as executor:
        results = executor.map(is_prime_number, data_range)
        return list(itertools.compress(data_range, results))12345678910
```
Замер на i7-7700K (4 ядра/8 потоков), количество потоков 12:
```python
>>> import timeit
>>>
>>> timeit.timeit(lambda: get_prime_numbers(10000), number=25)
4.640567486999998
>>> timeit.timeit(lambda: multi_thread_concurrent(10000), number=25)
8.37458275900002
>>>
>>> import os
>>> timeit.timeit(lambda: multi_thread_concurrent(10000, os.cpu_count() - 1), number=25)
8.937164508999558
```

| Характеристика       | `submit()`                                        | `map()`                               |
|----------------------|---------------------------------------------------|---------------------------------------|
| Использование         | Для одной функции с произвольными аргументами     | Для одной функции с итерабельным объектом |
| Возвращаемое значение | Объект `Future`  (.result() - получить результат) | Итератор результатов                  |
| Гибкость             | Более гибкий (можно использовать разные функции)  | Менее гибкий (одна функция для всех) |
| Удобство             | Требует явного управления результатами            | Проще в использовании для повторяющихся задач |

# Что такое GIL в Python?
**Глобальная блокировка интерпретатора** - в один момент времени разрешает только одному потоку управлять
интерпретатором Python

CPU-bound задачи:

• нагружают процессор (любая математика)

• для решения таких задач стоит использовать процессы
IO-bound задачи:

• зависят от ввода-вывода (работа с файлами, сетевые операции, запросы к БД)

• для решения таких задач идеально подходит многопоточность

## Многопроцессность
Задачи распределяются между несколькими процессами и
**могут выполняться параллельно:**
**multiprocessing**

| Характеристика       | Многопоточность                       | Многопроцессорность                  |
|----------------------|---------------------------------------|--------------------------------------|
| **Определение**      | Выполнение нескольких потоков в одном процессе | Выполнение нескольких процессов      |
| **Использование памяти** | Общая память между потоками          | Отдельная память для каждого процесса |
| **Подходящие задачи** | I/O bound (например, сетевые запросы) | CPU bound (например, вычисления)    |
| **Преимущества**     | Легкость управления памятью           | Эффективное использование многоядерных процессоров |
| **Недостатки**       | Ограничение GIL                      | Более сложное межпроцессное взаимодействие |


```python
import multiprocessing
import itertools
def multi_process(n: int, max_workers: int | None = None) -> list[int]:
    data_range = range(1, n + 1)

    with multiprocessing.Pool(max_workers) as pool:
        results = pool.map(is_prime_number, data_range)
        return list(itertools.compress(data_range, result
```
# Асинхронная модель
## Что такое Асинхронное программирование?
Длительную задачу можно выполнять в фоновом режиме отдельно от главного приложения

Система не блокируется и не ждет завершения задачи, а продолжает выполнять другие независимые действия

Когда задача завершится, мы получим уведомление, что можно обработать результат


