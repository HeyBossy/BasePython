# python -m venv env - создать виртуальное окружение

# .\env\Scripts\activate - Активирует виртуальное окружение `env` (работает на Windows).
# source env/bin/activate - убунту актвиация

# deactivate -  выключить

# pip install "fastapi[standard]"

# fastapi dev main.py - запустить сервак


from fastapi import FastAPI, HTTPException # Импортируем `FastAPI` для создания веб-приложения. # Импортируем `HTTPException` для обработки ошибок HTTP.

from pydantic import BaseModel # типо dataclass для описания данных но круче может автоматом вызывать ошибки если тип данных не верный + с фастапи работает

app = FastAPI() # Создаём объект приложения FastAPI.

class Note(BaseModel):
    # Определяем модель данных `Note`:
    # - `id`: уникальный идентификатор заметки (целое число).
    # - `text`: текст заметки (строка).
    # Pydantic автоматически проверяет и валидирует входные данные, соответствующие этим полям.
    id: int
    text: str


def generate_fake_data(n):
    '''  Возвращаем пару `(id, note - заметка)`.'''
    for i in range(1, n + 1):  # Создаём диапазон от 1 до n включительно.
        note = Note(id=i, text=f'Note #{i}')
        # Создаём объект `Note` с уникальным `id` и текстом `Note #i`.
        yield note.id, note

'''' словарь такой нужен ( "фейковая база данных)
    {
    1: Note(id=1, text="Note #1"),
    2: Note(id=2, text="Note #2"),
    3: Note(id=3, text="Note #3"),
    4: Note(id=4, text="Note #4"),
    5: Note(id=5, text="Note #5"),
}
'''
fake_db_data = dict(generate_fake_data(5))  # Генерируем фейковую базу данных на 5 записей
                                            # и преобразуем данные из генератора в словарь,
                                            # где ключ — это `id`, а значение — объект `Note`.

@app.get('/')  # Маршрут для HTTP GET-запроса по адресу `/`.
def read_all_notes() -> list[Note]:
    '''Функция возвращает список всех заметок из базы данных.'''
    return list(fake_db_data.values()) # Извлекаем все значения (объекты `Note`) из словаря и преобразуем их в список.

@app.get('/{note_id}') # Маршрут для HTTP GET-запроса с параметром `note_id`, например `/3`.
def read_note(note_id: int) -> Note:
    # Функция принимает параметр `note_id` (идентификатор заметки) и возвращает соответствующую заметку.
    '''
    curl 127.0.0.1:8000/3 - Вернёт заметку с id=3.
    Если указать, например, 10, и такой заметки нет (до 5 создавали), будет ошибка 404.
    '''
    if note_id not in fake_db_data:
        # Если `note_id` нет в базе данных:
        raise HTTPException(404, f'Note with id {note_id} not found') # Возбуждаем исключение HTTP 404 (Not Found) с сообщением об ошибке.
    return fake_db_data[note_id] # Если заметка найдена, возвращаем её.

# curl 127.0.0.1:8000 - Проверить ответ сервера для запроса всех заметок (возвращает fake_db_data).
# curl 127.0.0.1:8000/3 - Проверить заметку с `id=3`. Возвращает одну заметку.
# curl 127.0.0.1:8000/10 - Если заметка с таким id отсутствует, возвращает ошибку 404.


'''
Что делает HTTP GET запрос?
GET — это метод HTTP, который используется клиентом (например, браузером, curl, Postman и т.д.) для получения данных с сервера.
Он не отправляет тело запроса (то есть данных для обработки), а только запрашивает определённый ресурс.
Сервер отвечает на GET запрос, возвращая данные в виде JSON, HTML или другого формата.

Клиент (например, curl или браузер) отправляет GET-запрос на сервер: curl 127.0.0.1:8000/
Сервер вызывает функцию read_all_notes, которая:
- Берёт все значения из словаря fake_db_data.
- Возвращает их клиенту в виде JSON.
Пример ответа от сервера:

[
    {"id": 1, "text": "Note #1"},
    {"id": 2, "text": "Note #2"},
    {"id": 3, "text": "Note #3"},
    {"id": 4, "text": "Note #4"},
    {"id": 5, "text": "Note #5"}
]
'''
