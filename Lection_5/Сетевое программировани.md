# Архитектура клиент-сервер
**Client-Server** - вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены
между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами

Клиент и сервер взаимодействуют через вычислительную сеть посредством сетевых протоколов, но могут быть
расположены и на одной машине

Сервер ожидает от клиента запросы и предоставляет им свои ресурсы в виде данных или в виде сервисных
функций
# Сетевая модель TCP/IP
**Стек протоколов TCP/IP** - протоколы сгруппированы в уровни и их взаимодействие можно представить в виде
"стека" - слоев, накладывающихся друг на дру
## Канальный уровень (Link Layer)
Управляет передачей данных внутри **одной (локальной) сети** и используется для **физической доставки
данных**

**MAC-адрес** - уникальный физический адрес сетевого устройства,

48-битное число, обычно в виде шести пар шестнадцатеричных чисел

Чаще всего использует протоколы Ethernet или IEEE 802.11 (Wi-Fi)

**Ethernet-кадр** - единица данных для передачи информации между устройствами
## Межсетевой уровень (Internet Layer)
Обеспечивает маршрутизацию и доставку пакетов между устройствами в разных сетях, основной используемый
протокол - **IP**

**IP-адрес** - уникальный числовой идентификатор устройства в IP-сети:

• IPv4 - 32 бита, четыре десятичных числа, разделенных точками

• IPv6 - 128 бит, восемь групп шестнадцатеричных чисел, разделенных двоеточиями
Маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски сети:

## Транспортный уровень (Transport Layer)
Отвечает за передачу данных между приложениями на разных устройствах, обеспечивая нужный уровень
надежности и управления потоком

**TCP (Transmission Control Protocol)** - предоставляет поток данных с предварительной установкой соединения,
гарантирует целостность и порядок передаваемых данных

**UDP (User Datagram Protocol)** - обеспечивает передачу данных без установления соединения, а также без
гарантий доставки и упорядоченности; гарантирует только целостность доставленной датаграм

## Прикладной уровень (Application Layer)
Обеспечивает взаимодействие приложений с сетью

Приложения имеют свои собственные протоколы обмена данными:

• **HTTP** - для передачи гипертекста (браузер, веб-сервер, curl)

• SMTP - для отправки почты, IMAP/POP3 - для получения почты
(почтовые клиенты, sendmail, Thunderbird, The Bat)

• FTP - для передачи файлов (Filezilla)

• DHCP - для назначения IP-адресов

IP-адреса идентифицируют устройства на межсетевом уровне, но данные передаются между приложениями и для
их идентификации используются порты

Комбинация IP-адреса и порта называется **сокетом**
# Socket API
Что такое сокет?

**Изначально сокеты** - это способ общения программ друг с другом, используя файловые дескрипторы ОС UNIX

**Дескриптор файла** - это простое целое число, связанное ОС с открытым файлом

Программы в Unix при абсолютно любом вводе-выводе читают или пишут в файловый дескриптор
## Типы файлов
Linux унаследовал философию Unix, где все является файлом. Конечно нужно разъяснить, что существуют разные
типы файлов:

• обычные файлы - это как раз то, что в Windows принято считать файлом, т.е. текстовые и исполняемые файлы,
файлы изображений, видео, библиотек и т.п.

• специальные файлы - это символические ссылки, сокеты, файлы устройств, символьные файлы, туннели и
именованные туннели

• директории - позволяют группировать файлы и другие директории для упрощения навигации
## Семейство протоколов сокета

• AF_INET - IPv4 протоколы Ethernet

• AF_INET6 - IPv6 протоколы Ethernet

• AF_UNIX - локальное соединение

## Типы сокетов

• SOCK_STREAM - обеспечивает создание двусторонних надежных и последовательных потоков байтов,
поддерживающих соединения

• SOCK_DGRAM - поддерживает датаграммы (ненадежные сообщения с ограниченной длиной и не
поддерживающие соединения)
## Основные функции

• **socket** - Создать новый сокет и вернуть файловый дескриптор

• **setsockopt** - Установить флаги на сокете, SOL_SOCKET - присвоение параметра на уровне библиотеки сокетов

• **send** - Отправить (записать) данные в сокет, возвращает кол-во отправленных байт, либо -1 в случае ошибки
**sendall** - высокоуровневый метод в модуле Python, который отправляет весь буффер, в случае ошибки бросает
исключение

• **recv** - Получить (прочитать) данные из сокета

• **close** - Закрыть соединение
## Серверный сокет
• **bind** - Связать сокет с IP-адресом и портом

• **listen** - Объявить о желании принимать соединения

Слушает порт и ждет когда будет установлено соединение


• **accept** - Принять запрос на установку соединения

```python
from datetime import datetime  # Импортируем класс datetime для получения текущего времени.
import socket  # Импортируем модуль socket для работы с сетевыми соединениями.

# Создаем объект сокета с использованием семейства адресов IPv4 (AF_INET) и протокола TCP (SOCK_STREAM).
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    # Устанавливаем опцию SO_REUSEADDR, чтобы можно было повторно использовать адрес и порт.
    # Это полезно при перезапуске сервера, чтобы избежать ошибки "Address already in use".
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    # Привязываем сокет к локальному адресу ('localhost') и порту 8000.
    sock.bind(('localhost', 8000))
    
    # ставит сервер в режим ожидания подключений, с очередью из 2 клиентов.
    sock.listen(2)
    
    # Бесконечный цикл для обработки входящих соединений.
    while 1:
        # Принимаем входящее соединение. 
        # `conn` — новый сокет для общения с клиентом.
        # `addr` — адрес клиента (кортеж с IP и портом).
        conn, addr = sock.accept()
        
        # Печатаем сообщение о подключении клиента.
        print(f'Client {addr} connected')
        
        # Создаем строку с текущим временем в формате ISO 8601 и добавляем символ новой строки.
        response = datetime.now().isoformat() + '\n'
        
        # Отправляем строку клиенту в виде байтов (метод `encode` преобразует строку в байты с кодировкой UTF-8).
        conn.sendall(response.encode('utf-8'))
        
        # Закрываем соединение с клиентом.
        conn.close()
```
## Клиентский сокет
• **connect** - Установить соединение
```python3
import socket  # Импортируем модуль socket для работы с сетевыми соединениями.

# Создаем объект сокета с использованием семейства адресов IPv4 (AF_INET) и протокола TCP (SOCK_STREAM).
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    # Устанавливаем соединение с сервером, который работает на localhost и порту 8000.
    sock.connect(('localhost', 8000))
    
    # Получаем ответ от сервера. Максимальный размер данных, которые мы готовы принять, равен 1024 байта.
    response = sock.recv(1024)
    
    # Расшифровываем полученные данные из байтов в строку, используя кодировку UTF-8.
    print(response.decode('utf-8'))

```
## Основные отличия

| **Серверный сокет**                          | **Клиентский сокет**                    |
|----------------------------------------------|-----------------------------------------|
| Работает в режиме ожидания соединений.       | Активно подключается к серверу.         |
| Использует `bind` для привязки к адресу/порту.| Использует `connect` для подключения.   |
| Вызывает `listen` для установки очереди.     | Нет этапа `listen`.                     |
| Принимает соединения через `accept`.         | Непосредственно устанавливает соединение.|
| Работает в бесконечном цикле для обработки клиентов.| Завершается после получения/отправки данных.|
| Часто используется для обслуживания множества клиентов.| Обычно служит одному серверу.          |
# HTTP HyperText Transfer Protocol
Протокол передачи гипертекста - в настоящий момент используется
для передачи произвольных данных, работает поверх TCP соединения

Различия:

**TCP:** Передает данные как "труба", без анализа содержимого. (Устанавливается соединение (TCP "рукопожатие").
Данные отправляются, разбиваются на пакеты.
Каждый пакет проверяется и подтверждается.
Если пакет потерян, TCP повторно отправляет его.
Соединение закрывается, когда данные доставлены.)

**HTTPS**: Сначала шифрует данные (например, ваш пароль или номер карты), а потом использует TCP для их передачи.
## Как работает протокол?
**Заголовки** - формат сообщений, которыми могут обмениваться клиенты и сервера:

• клиент отправляет **заголовки запроса:**
```
Метод URI Протокол/Версия
Имя_заголовка: Значение_заголовка
...
Имя_заголовка: Значение_заголовка
\r\n
Тело_запроса
```

• сервер отправляет **заголовки ответа:**
```
Протокол/Версия Код [Сообщение]
Имя_заголовка: Значение_заголовка
...
Имя_заголовка: Значение_заголовка
\r\n
\r\n
Тело_ответа
```
# Пример HTTP-заголовков 

HTTP-заголовки — это текстовые данные, которые передаются между клиентом и сервером при запросах и ответах. Они содержат информацию о запросе или ответе, включая тип содержимого, статус ответа, длину и т.д.

## Запрос 1: Получение главной страницы (`GET / HTTP/2`)

### HTTP-запрос от клиента:
```http
GET / HTTP/2
Host: site.loc
user-agent: curl/7.72.0
accept: */*
```

#### Комментарии:
1. `GET / HTTP/2`:
   - **GET**: Метод HTTP-запроса, используемый для получения данных.
   - `/`: URL запрашиваемого ресурса (в данном случае, главная страница).
   - `HTTP/2`: Используемая версия протокола HTTP.

2. `Host: site.loc`:
   - Указывает имя хоста (`site.loc`), к которому клиент подключается.

3. `user-agent: curl/7.72.0`:
   - Информация о клиентском приложении, которое делает запрос (здесь `curl` версии `7.72.0`).

4. `accept: */*`:
   - Указывает, что клиент готов принять любые типы содержимого (`*/*` означает "всё").

---

### HTTP-ответ от сервера:
```http
HTTP/2 302
server: nginx
date: Sat, 07 Nov 2020 17:14:54 GMT
content-type: text/html
content-length: 138
location: https://site.loc/posts
```

#### Комментарии:
1. `HTTP/2 302`:
   - Версия HTTP (`HTTP/2`) и статус-код `302` (перенаправление).

2. `server: nginx`:
   - Информация о веб-сервере, обработавшем запрос (здесь `nginx`).

3. `date: Sat, 07 Nov 2020 17:14:54 GMT`:
   - Время обработки запроса на сервере.

4. `content-type: text/html`:
   - Тип содержимого в ответе (HTML-страница).

5. `content-length: 138`:
   - Длина тела ответа в байтах.

6. `location: https://site.loc/posts`:
   - Указывает, куда клиенту следует перейти (редирект).

---

## Запрос 2: Перенаправление на `/posts`

### HTTP-запрос от клиента:
```http
GET /posts HTTP/2
Host: site.loc
user-agent: curl/7.72.0
accept: */*
```

#### Комментарии:
1. `GET /posts HTTP/2`:
   - Запрос на получение страницы `/posts` с использованием метода `GET`.

2. Остальные заголовки (`Host`, `user-agent`, `accept`) аналогичны первому запросу.

---

### HTTP-ответ от сервера:
```http
HTTP/2 200
server: nginx
date: Sat, 07 Nov 2020 17:14:54 GMT
content-type: text/html; charset=utf-8
content-length: 4203
<!doctype html>
<...>
</html>
```

#### Комментарии:
1. `HTTP/2 200`:
   - Статус-код `200`, означающий успешную обработку запроса.

2. `server: nginx`:
   - Указывает сервер, обработавший запрос.

3. `content-type: text/html; charset=utf-8`:
   - Тип содержимого — HTML, с указанием кодировки (`utf-8`).

4. `content-length: 4203`:
   - Длина HTML-документа в байтах.

5. Тело ответа (`<!doctype html> ... </html>`):
   - Содержит сам HTML-документ, запрошенный клиентом.

---

### Итог:
- Клиент отправил запрос на главную страницу (`/`).
- Сервер перенаправил клиента на страницу `/posts` с кодом `302`.
- Клиент выполнил запрос на `/posts` и получил успешный ответ с кодом `200` и содержимым страницы.

# Методы протокола HTTP
Спецификацией HTTP определен ряд методов для передачи запросов между компьютерами, но чаще всего из них
используются только два:

• **GET** - через адресную строку браузера (получение данных по URL)

• **POST** - отправка данных с помощью HTML-форм